import 'dotenv/config';
import 'reflect-metadata';
import { NestFactory } from '@nestjs/core';
import { DataSource } from 'typeorm';
import { AppModule } from './app.module';
import {
  ValidationPipe,
  Logger,
  ClassSerializerInterceptor,
  BadRequestException,
} from '@nestjs/common';
import { GlobalExceptionFilter } from './common/global-exception.filter';
import { Reflector } from '@nestjs/core';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import helmet from 'helmet';
import * as compression from 'compression';
import { json, urlencoded } from 'express';
import { EtagInterceptor } from './common/interceptors/etag.interceptor';
import * as crypto from 'crypto';
import * as Sentry from '@sentry/node';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, { bodyParser: true });

  // Initialize Sentry (optional) for error monitoring
  try {
    const dsn = process.env.SENTRY_DSN;
    if (dsn) {
      Sentry.init({
        dsn,
        environment: process.env.SENTRY_ENVIRONMENT || process.env.NODE_ENV || 'development',
        // Sample all errors, and a portion of transactions
        tracesSampleRate: parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE || '0.05'),
        profilesSampleRate: parseFloat(process.env.SENTRY_PROFILES_SAMPLE_RATE || '0'),
        // Scrub PII before sending
        beforeSend(event) {
          try {
            // Remove potentially sensitive headers
            const headers = (event.request as any)?.headers;
            if (headers) {
              const redactedHeaders = ['authorization', 'cookie', 'set-cookie', 'x-api-key'];
              for (const h of redactedHeaders) {
                if (headers[h]) headers[h] = '[REDACTED]';
              }
            }
            // Remove request body
            if ((event.request as any)?.data) {
              (event.request as any).data = '[REDACTED]';
            }
            // Remove user info
            if (event.user) {
              event.user = { id: event.user?.id } as any;
            }
          } catch {}
          return event;
        },
      });
    }
  } catch {
    // ignore
  }

  // Security headers (CSP configured to allow Swagger UI when enabled)
  app.use(
    helmet({
      contentSecurityPolicy: {
        useDefaults: true,
        directives: {
          defaultSrc: ["'self'"],
          scriptSrc: [
            "'self'",
            // Allow inline scripts generated by Swagger UI
            "'unsafe-inline'",
          ],
          styleSrc: [
            "'self'",
            "'unsafe-inline'", // Swagger UI injects inline styles
          ],
          imgSrc: ["'self'", 'data:'],
          fontSrc: ["'self'", 'data:'],
          connectSrc: ["'self'"],
          objectSrc: ["'none'"],
          frameAncestors: ["'none'"],
          baseUri: ["'self'"],
          formAction: ["'self'"],
          // Allow swagger's worker if used (rare). Keep tight by default
          workerSrc: ["'self'"],
        },
      },
      referrerPolicy: { policy: 'no-referrer' },
      xDnsPrefetchControl: { allow: false },
      crossOriginOpenerPolicy: { policy: 'same-origin' },
      crossOriginResourcePolicy: { policy: 'same-origin' },
      crossOriginEmbedderPolicy: false, // keep disabled to avoid breaking dev assets if not COEP-compliant
      hidePoweredBy: true,
      hsts: process.env.NODE_ENV === 'production' ? undefined : false,
    }),
  );
  // Disable Express automatic ETag; we'll manage ETag via interceptor selectively
  const expressApp = app.getHttpAdapter().getInstance() as
    | (import('express').Express & { set?: (k: string, v: unknown) => void })
    | undefined;
  if (expressApp?.set) {
    expressApp.set('etag', false);
    // Ensure correct IP and protocol when behind a reverse proxy (Nginx/ALB)
    // Enables req.ip and secure cookies to work as expected
    try {
      expressApp.set('trust proxy', (process.env.TRUST_PROXY as any) ?? 1);
    } catch {}
  }
  // Accept both JSON and application/x-www-form-urlencoded payloads
  app.use(urlencoded({ extended: true, limit: '50mb' }));
  app.use(json({ limit: '50mb' }));
  // Enable gzip compression for responses (disable by default in production; offload to Nginx)
  const enableNodeCompression = (process.env.ENABLE_NODE_COMPRESSION || '').toLowerCase() === 'true';
  if (enableNodeCompression || process.env.NODE_ENV !== 'production') {
    const compressionFn: any = (compression as any)?.default || (compression as any);
    app.use(
      compressionFn({
        threshold: 1024,
      }),
    );
  }
  // Ensure temp upload directory exists for Multer disk storage
  try {
    const fs = await import('fs');
    await fs.promises.mkdir('/tmp/uploads', { recursive: true });
  } catch {
    // ignore
  }
  // Enable all log levels for better visibility in production
  app.useLogger(['log', 'error', 'warn', 'debug', 'verbose']);

  // CORS configuration (supports env list + robust preflight handling)
  const defaultAllowedOrigins = [
    'https://suuq.ugasfuad.com',
    'https://admin.suuq.ugasfuad.com',
  'https://api.suuq.ugasfuad.com',
    'http://localhost:5173',
    'http://localhost:3000',
    'http://localhost:3001',
  ];
  const allowedOrigins = (
    process.env.ALLOWED_ORIGINS
      ? process.env.ALLOWED_ORIGINS.split(',')
      : defaultAllowedOrigins
  ).map((o) => o.trim());

  app.enableCors({
    origin: (
      origin: string | undefined,
      callback: (err: Error | null, allow?: boolean) => void,
    ) => {
      // Allow no-origin requests (mobile apps, curl, server-to-server)
      if (!origin) return callback(null, true);
      if (allowedOrigins.includes(origin)) return callback(null, true);
      return callback(new Error('Not allowed by CORS'));
    },
    methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE', 'OPTIONS'],
    credentials: true,
    allowedHeaders: [
      'Origin',
      'origin',
      'X-Requested-With',
      'x-requested-with',
      'X-App-Version',
      'x-app-version',
      'X-Platform',
      'x-platform',
      'Content-Type',
      'content-type',
      'Accept',
      'accept',
      'Authorization',
      'authorization',
      'Cache-Control',
      'cache-control',
      'Pragma',
      'pragma',
      'If-None-Match',
      'if-none-match',
      'If-Match',
      'if-match',
      'If-Modified-Since',
      'if-modified-since',
    ],
    exposedHeaders: [
      'Authorization',
      'ETag',
      'Last-Modified',
      'Cache-Control',
      'Retry-After',
      // For admin UIs like React Admin that read totals from headers
      'Content-Range',
      'X-Total-Count',
    ],
    preflightContinue: false,
    optionsSuccessStatus: 204,
  });

  // JSON already configured above

  // Ensure caching/CDNs vary responses per requesting origin
  app.use(
    (
      req: import('express').Request,
      res: import('express').Response,
      next: import('express').NextFunction,
    ) => {
      res.setHeader('Vary', 'Origin');
      next();
    },
  );

  // Improved logging with sanitization
  app.use(
    (
      req: import('express').Request & { id?: string },
      res: import('express').Response,
      next: import('express').NextFunction,
    ) => {
      const requestId = (req as { id?: string }).id;
      const isProduction = process.env.NODE_ENV === 'production';

      if (isProduction) {
        // Structured logging in production
        // Apply simple sampling to reduce log volume for high-fanout endpoints
        // Default sample rate: 1/N (lower = more logs). Override via LOG_SAMPLE_N
        const sampleN = Math.max(1, parseInt(process.env.LOG_SAMPLE_N || '5', 10));
        const shouldLog = Math.floor(Math.random() * sampleN) === 0;

        if (!shouldLog) {
          return next();
        }

        const logData: Record<string, unknown> = {
          requestId,
          method: req.method,
          url: req.url,
          userAgent: req.headers['user-agent'],
          timestamp: new Date().toISOString(),
        };
        // Avoid JSON-stringifying request bodies in production to reduce CPU overhead
        // You can enable body logging for specific routes under debug only.

        // Also scrub a subset of sensitive headers
        try {
          if ((logData as any).headers) {
            const scrub = ['authorization', 'cookie', 'x-api-key'];
            for (const h of scrub) {
              if ((logData as any).headers[h]) (logData as any).headers[h] = '[REDACTED]';
            }
          }
        } catch {}
        console.log(JSON.stringify(logData));
      } else {
        // Verbose logging in development
        console.log('--- Logging middleware triggered ---');
        console.log(`[${req.method}] ${req.url} (ID: ${requestId})`);
        console.log('Request headers:', req.headers);

        // Do not attempt to log body for multipart/form-data
        const contentType = req.headers['content-type'];
        if (contentType && contentType.includes('multipart/form-data')) {
          console.log('Incoming request body: <multipart/form-data stream>');
        } else if (typeof req.body !== 'undefined') {
          const bodyString = JSON.stringify(req.body as unknown);
          console.log(
            'Incoming request body:',
            bodyString === '{}' ? '<empty object>' : bodyString,
          );
        } else {
          console.log('Incoming request body: <undefined>');
        }
      }

      next();
    },
  );

  // Tiny plain GET /pdown endpoint (no prefix) to quiet external probes
  try {
    const http = app.getHttpAdapter().getInstance() as import('express').Express;
    http.get('/pdown', (_req, res) => res.status(200).send('OK'));
    // Quiet common probes
    http.get('/robots.txt', (_req, res) => {
      res.type('text/plain').status(200).send('User-agent: *\nDisallow: /');
    });
    http.get('/favicon.ico', (_req, res) => res.status(204).end());
  } catch {
    // ignore if adapter is not Express
  }

  // Set global prefix for all routes
  app.setGlobalPrefix('api');

  // Add logger for validation errors
  const logger = new Logger('ValidationPipe');

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      transformOptions: { enableImplicitConversion: true },
      forbidUnknownValues: false,
      exceptionFactory: (errors) => {
        const messages = errors.map((error) => {
          const constraints = error.constraints
            ? Object.values(error.constraints)
            : [];
          return `${error.property}: ${constraints.join(', ')}`;
        });
        logger.warn(`Validation failed: ${messages.join('; ')}`);
        return new BadRequestException(messages);
      },
    }),
  );

  app.useGlobalInterceptors(new ClassSerializerInterceptor(app.get(Reflector)));
  app.useGlobalInterceptors(new EtagInterceptor(300));
  // Register global exception filter for detailed error logging
  app.useGlobalFilters(new GlobalExceptionFilter());
  // Tune HTTP server-level timeouts to play nicely with reverse proxies
  try {
    const server = app.getHttpServer() as unknown as {
      keepAliveTimeout?: number;
      headersTimeout?: number;
      requestTimeout?: number;
      setTimeout?: (msecs: number, cb?: () => void) => void;
    };
    // Keep connections alive slightly longer than proxy to let proxy control reuse
    server.keepAliveTimeout = parseInt(process.env.KEEP_ALIVE_TIMEOUT_MS || '65000', 10);
    // A little higher than keepAliveTimeout to avoid premature timeout
    server.headersTimeout = parseInt(process.env.HEADERS_TIMEOUT_MS || '66000', 10);
    // Disable per-request inactivity timeout by default (proxy should enforce)
    server.requestTimeout = parseInt(process.env.REQUEST_TIMEOUT_MS || '0', 10) || 0;
    // Also ensure the legacy socket timeout is disabled
    if (typeof server.setTimeout === 'function') {
      server.setTimeout(parseInt(process.env.SOCKET_TIMEOUT_MS || '0', 10) || 0);
    }
  } catch {}
  // Request ID propagation
  app.use(
    (
      req: import('express').Request,
      res: import('express').Response,
      next: import('express').NextFunction,
    ) => {
      const rid =
        (req.headers['x-request-id'] as string | undefined) ||
        (typeof crypto.randomUUID === 'function'
          ? crypto.randomUUID()
          : Math.random().toString(36).slice(2));
      // Ensure the header is set on response; don't mutate req.headers type unsafely
      res.setHeader('x-request-id', rid);
      next();
    },
  );
  // (removed temporary route introspection)
  // Auto-run DB migrations unless disabled (default off in production)
  try {
    const ds = app.get(DataSource);
    const allowAuto =
      (process.env.AUTO_MIGRATE ?? (process.env.NODE_ENV === 'production' ? 'false' : 'true')) !== 'false' &&
      process.env.NODE_ENV !== 'test';
    if (allowAuto && ds && typeof ds.runMigrations === 'function') {
      await ds.runMigrations();
      Logger.log('Database migrations executed on startup', 'Bootstrap');
    }
  } catch (_e: unknown) {
    const msg = _e instanceof Error ? _e.message : 'unknown error';
    Logger.warn(`Auto migration skipped/failed: ${msg}`, 'Bootstrap');
  }
  // Swagger (gated by env)
  try {
    const enableDocs =
      (process.env.SWAGGER_ENABLED || 'false').toLowerCase() === 'true';
    if (enableDocs) {
      const config = new DocumentBuilder()
        .setTitle('Suuq API')
        .setDescription('Suuq backend API')
        .setVersion(process.env.npm_package_version || '1.0.0')
        .addBearerAuth()
        .build();
      const document = SwaggerModule.createDocument(app, config);
      SwaggerModule.setup('api/docs', app, document, {
        swaggerOptions: { persistAuthorization: true },
      });
      Logger.log('Swagger documentation available at /api/docs', 'Bootstrap');
    }
  } catch {
    Logger.warn('Swagger setup failed (disabled or error)', 'Bootstrap');
  }

  const port = parseInt(process.env.PORT || '3000', 10);
  const host = process.env.HOST || '0.0.0.0';
  await app.listen(port, host);
  const appUrl = await app.getUrl();
  console.log(`Application is running on: ${appUrl}`);
}
void bootstrap();
