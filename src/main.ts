import 'dotenv/config';
import 'reflect-metadata';
import { NestFactory } from '@nestjs/core';
import { DataSource } from 'typeorm';
import { AppModule } from './app.module';
import {
  ValidationPipe,
  Logger,
  ClassSerializerInterceptor,
  BadRequestException,
} from '@nestjs/common';
import { GlobalExceptionFilter } from './common/global-exception.filter';
import { Reflector } from '@nestjs/core';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import helmet from 'helmet';
import { json, urlencoded } from 'express';
import { EtagInterceptor } from './common/interceptors/etag.interceptor';
import * as crypto from 'crypto';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, { bodyParser: true });

  // Security headers (CSP configured to allow Swagger UI when enabled)
  app.use(
    helmet({
      contentSecurityPolicy: {
        useDefaults: true,
        directives: {
          defaultSrc: ["'self'"],
          scriptSrc: [
            "'self'",
            // Allow inline scripts generated by Swagger UI
            "'unsafe-inline'",
          ],
          styleSrc: [
            "'self'",
            "'unsafe-inline'", // Swagger UI injects inline styles
          ],
          imgSrc: ["'self'", 'data:'],
          fontSrc: ["'self'", 'data:'],
          connectSrc: ["'self'"],
          objectSrc: ["'none'"],
          frameAncestors: ["'none'"],
          baseUri: ["'self'"],
          formAction: ["'self'"],
          // Allow swagger's worker if used (rare). Keep tight by default
          workerSrc: ["'self'"],
        },
      },
      referrerPolicy: { policy: 'no-referrer' },
      xDnsPrefetchControl: { allow: false },
      crossOriginOpenerPolicy: { policy: 'same-origin' },
      crossOriginResourcePolicy: { policy: 'same-origin' },
      crossOriginEmbedderPolicy: false, // keep disabled to avoid breaking dev assets if not COEP-compliant
      hidePoweredBy: true,
      hsts: process.env.NODE_ENV === 'production' ? undefined : false,
    }),
  );
  // Disable Express automatic ETag; we'll manage ETag via interceptor selectively
  const expressApp = app.getHttpAdapter().getInstance() as
    | (import('express').Express & { set?: (k: string, v: unknown) => void })
    | undefined;
  if (expressApp?.set) {
    expressApp.set('etag', false);
  }
  // Accept both JSON and application/x-www-form-urlencoded payloads
  app.use(urlencoded({ extended: true, limit: '50mb' }));
  app.use(json({ limit: '50mb' }));
  // Ensure temp upload directory exists for Multer disk storage
  try {
    const fs = await import('fs');
    await fs.promises.mkdir('/tmp/uploads', { recursive: true });
  } catch {
    // ignore
  }
  // Enable all log levels for better visibility in production
  app.useLogger(['log', 'error', 'warn', 'debug', 'verbose']);

  // CORS configuration (supports env list + robust preflight handling)
  const defaultAllowedOrigins = [
    'https://suuq.ugasfuad.com',
    'https://admin.suuq.ugasfuad.com',
    'http://localhost:5173',
    'http://localhost:3000',
    'http://localhost:3001',
  ];
  const allowedOrigins = (
    process.env.ALLOWED_ORIGINS
      ? process.env.ALLOWED_ORIGINS.split(',')
      : defaultAllowedOrigins
  ).map((o) => o.trim());

  app.enableCors({
    origin: (
      origin: string | undefined,
      callback: (err: Error | null, allow?: boolean) => void,
    ) => {
      // Allow no-origin requests (mobile apps, curl, server-to-server)
      if (!origin) return callback(null, true);
      if (allowedOrigins.includes(origin)) return callback(null, true);
      return callback(new Error('Not allowed by CORS'));
    },
    methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE', 'OPTIONS'],
    credentials: true,
    allowedHeaders: [
      'Origin',
      'origin',
      'X-Requested-With',
      'x-requested-with',
      'X-App-Version',
      'x-app-version',
      'X-Platform',
      'x-platform',
      'Content-Type',
      'content-type',
      'Accept',
      'accept',
      'Authorization',
      'authorization',
      'Cache-Control',
      'cache-control',
      'Pragma',
      'pragma',
      'If-None-Match',
      'if-none-match',
      'If-Match',
      'if-match',
      'If-Modified-Since',
      'if-modified-since',
    ],
    exposedHeaders: [
      'Authorization',
      'ETag',
      'Last-Modified',
      'Cache-Control',
      'Retry-After',
      // For admin UIs like React Admin that read totals from headers
      'Content-Range',
      'X-Total-Count',
    ],
    preflightContinue: false,
    optionsSuccessStatus: 204,
  });

  // JSON already configured above

  // Ensure caching/CDNs vary responses per requesting origin
  app.use(
    (
      req: import('express').Request,
      res: import('express').Response,
      next: import('express').NextFunction,
    ) => {
      res.setHeader('Vary', 'Origin');
      next();
    },
  );

  // Improved logging with sanitization
  app.use(
    (
      req: import('express').Request & { id?: string },
      res: import('express').Response,
      next: import('express').NextFunction,
    ) => {
      const requestId = (req as { id?: string }).id;
      const isProduction = process.env.NODE_ENV === 'production';

      if (isProduction) {
        // Structured logging in production
        const logData: Record<string, unknown> = {
          requestId,
          method: req.method,
          url: req.url,
          userAgent: req.headers['user-agent'],
          timestamp: new Date().toISOString(),
        };

        // Sanitize body in production - redact sensitive fields
        if (req.body && typeof req.body === 'object') {
          const sanitizedBody: Record<string, unknown> = {
            ...(req.body as Record<string, unknown>),
          };
          const sensitiveFields = [
            'password',
            'token',
            'secret',
            'authorization',
            'jwt',
          ];

          for (const field of sensitiveFields) {
            if (sanitizedBody[field]) {
              sanitizedBody[field] = '[REDACTED]';
            }
          }

          logData['body'] = sanitizedBody;
        }

        console.log(JSON.stringify(logData));
      } else {
        // Verbose logging in development
        console.log('--- Logging middleware triggered ---');
        console.log(`[${req.method}] ${req.url} (ID: ${requestId})`);
        console.log('Request headers:', req.headers);

        // Do not attempt to log body for multipart/form-data
        const contentType = req.headers['content-type'];
        if (contentType && contentType.includes('multipart/form-data')) {
          console.log('Incoming request body: <multipart/form-data stream>');
        } else if (typeof req.body !== 'undefined') {
          const bodyString = JSON.stringify(req.body as unknown);
          console.log(
            'Incoming request body:',
            bodyString === '{}' ? '<empty object>' : bodyString,
          );
        } else {
          console.log('Incoming request body: <undefined>');
        }
      }

      next();
    },
  );

  // Tiny plain GET /pdown endpoint (no prefix) to quiet external probes
  try {
    const http = app.getHttpAdapter().getInstance() as import('express').Express;
    http.get('/pdown', (_req, res) => res.status(200).send('OK'));
    // Quiet common probes
    http.get('/robots.txt', (_req, res) => {
      res.type('text/plain').status(200).send('User-agent: *\nDisallow: /');
    });
    http.get('/favicon.ico', (_req, res) => res.status(204).end());
  } catch {
    // ignore if adapter is not Express
  }

  // Set global prefix for all routes
  app.setGlobalPrefix('api');

  // Add logger for validation errors
  const logger = new Logger('ValidationPipe');

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      exceptionFactory: (errors) => {
        const messages = errors.map((error) => {
          const constraints = error.constraints
            ? Object.values(error.constraints)
            : [];
          return `${error.property}: ${constraints.join(', ')}`;
        });
        logger.warn(`Validation failed: ${messages.join('; ')}`);
        return new BadRequestException(messages);
      },
    }),
  );

  app.useGlobalInterceptors(new ClassSerializerInterceptor(app.get(Reflector)));
  app.useGlobalInterceptors(new EtagInterceptor(300));
  // Register global exception filter for detailed error logging
  app.useGlobalFilters(new GlobalExceptionFilter());
  // Request ID propagation
  app.use(
    (
      req: import('express').Request,
      res: import('express').Response,
      next: import('express').NextFunction,
    ) => {
      const rid =
        (req.headers['x-request-id'] as string | undefined) ||
        (typeof crypto.randomUUID === 'function'
          ? crypto.randomUUID()
          : Math.random().toString(36).slice(2));
      // Ensure the header is set on response; don't mutate req.headers type unsafely
      res.setHeader('x-request-id', rid);
      next();
    },
  );
  // (removed temporary route introspection)
  // Auto-run DB migrations unless disabled
  try {
    const ds = app.get(DataSource);
    const allowAuto =
      (process.env.AUTO_MIGRATE ?? 'true') !== 'false' &&
      process.env.NODE_ENV !== 'test';
    if (allowAuto && ds && typeof ds.runMigrations === 'function') {
      await ds.runMigrations();
      Logger.log('Database migrations executed on startup', 'Bootstrap');
    }
  } catch (_e: unknown) {
    const msg = _e instanceof Error ? _e.message : 'unknown error';
    Logger.warn(`Auto migration skipped/failed: ${msg}`, 'Bootstrap');
  }
  // Swagger (gated by env)
  try {
    const enableDocs =
      (process.env.SWAGGER_ENABLED || 'false').toLowerCase() === 'true';
    if (enableDocs) {
      const config = new DocumentBuilder()
        .setTitle('Suuq API')
        .setDescription('Suuq backend API')
        .setVersion(process.env.npm_package_version || '1.0.0')
        .addBearerAuth()
        .build();
      const document = SwaggerModule.createDocument(app, config);
      SwaggerModule.setup('api/docs', app, document, {
        swaggerOptions: { persistAuthorization: true },
      });
      Logger.log('Swagger documentation available at /api/docs', 'Bootstrap');
    }
  } catch {
    Logger.warn('Swagger setup failed (disabled or error)', 'Bootstrap');
  }

  const port = parseInt(process.env.PORT || '3000', 10);
  const host = process.env.HOST || '0.0.0.0';
  await app.listen(port, host);
  const appUrl = await app.getUrl();
  console.log(`Application is running on: ${appUrl}`);
}
void bootstrap();
